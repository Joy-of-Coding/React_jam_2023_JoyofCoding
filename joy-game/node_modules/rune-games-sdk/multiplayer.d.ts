/*
Copyright (c) 2022 Rune AI Inc.
All rights reserved.

This code is proprietary to Rune AI Inc.
The code may be used solely for accessing the Service provided by Rune AI Inc. following the Rune Terms of Service ("Terms") accessible at rune.ai/eula. You may not use this code for any use or purpose other than as expressly permitted by the Terms.
Restrictions set forth in the Terms include, but is not limited to, that you may not copy, adapt, modify, prepare derivative works based upon, distribute, license, sell, transfer, publicly display, publicly perform, transmit, stream, broadcast, attempt to discover any source code, reverse engineer, decompile, dissemble, or otherwise exploit the code as a whole or any portion of the code.
*/
type UntypedGameState = Record<string, any>;
type UntypedInitLogicAction = (params?: any) => void;
type UntypedInitLogicActions = Record<string, UntypedInitLogicAction>;
type GameConfig = {
    minPlayers: number;
    maxPlayers: number;
    eventCallbacks: {
        playerLeft: boolean;
        playerJoined: boolean;
    };
    update: boolean;
};
type SessionId = string;
type GameId = number;
type PlayerId = string;
type RandomSeed = number;
type Player = {
    playerId: PlayerId;
    displayName: string;
    avatarUrl: string;
};
type Players = Record<PlayerId, Player>;
type UserId = number;
type Spectator = {
    playerId: undefined;
};
type User = (Player | Spectator) & {
    userId: number;
};
type Users = Record<UserId, User>;

declare global {
    var ReactNativeWebView: {
        postMessage: (data: string) => void;
    } | undefined;
}
type GameToClient = {
    type: "INIT";
    version: string;
} | {
    type: "ERR";
    gamePlayUuid?: string;
    errMsg: string;
} | {
    type: "WARNING";
    gamePlayUuid: string;
    msg: string;
    data?: unknown;
} | {
    type: "WINDOW_ERR";
    err: {
        msg: string;
        filename: string;
        lineno: number;
        colno: number;
    };
} | {
    type: "WINDOW_ALERT";
    message: string;
} | {
    type: "BROWSER_INITIAL_OVERLAY_CLICKED";
} | {
    type: "BROWSER_IFRAME_LOADED";
};
type ClientToGame = {
    type: "setForceMuteStatus";
    muted: boolean;
};

type GameOverOptions = {
    players: {
        [playerId: PlayerId]: "WON" | "LOST" | number;
    };
    delayPopUp?: boolean;
};
type GameOverGameEnded = {
    reason: "gameEnded";
    options?: GameOverOptions;
};
type GameOverPlayerLeft = {
    reason: "playerLeft";
};
type GameOverMinPlayers = {
    reason: "minPlayers";
};
type GameOverError = {
    reason: "err";
};
type GameOverContext = (GameOverMinPlayers | GameOverPlayerLeft | GameOverGameEnded | GameOverError) & {
    players: Players;
};

type LogFn = {
    (obj: object, msg: string): void;
    (msg: string): void;
};
type MsgLogger = {
    error: LogFn;
    warn: LogFn;
    info: LogFn;
};

type EventContext<GameState> = {
    game: GameState;
    allPlayerIds: PlayerId[];
};
type UpdateContext<GameState> = {
    game: GameState;
    allPlayerIds: PlayerId[];
};
type ActionContext<GameState> = {
    game: GameState;
    playerId: PlayerId;
    allPlayerIds: PlayerId[];
};
type InitLogicEvent<GameState> = (playerId: PlayerId, eventContext: EventContext<GameState>) => void;
type InitLogicEvents<GameState> = {
    playerJoined?: InitLogicEvent<GameState>;
    playerLeft?: InitLogicEvent<GameState>;
};
type InitLogicUpdate<GameState> = (updateContext: UpdateContext<GameState>) => void;
type InitLogicActions<GameState, GameActions extends UntypedInitLogicActions> = {
    [key in keyof GameActions]: (params: Parameters<GameActions[key]>[0], actionContext: ActionContext<GameState>) => void;
};
type InitLogicParams<GameState, GameActions extends UntypedInitLogicActions> = {
    minPlayers: number;
    maxPlayers: number;
    setup: (allPlayerIds: PlayerId[]) => GameState;
    actions: InitLogicActions<GameState, GameActions>;
    events?: InitLogicEvents<GameState>;
    update?: InitLogicUpdate<GameState>;
};
type RuneSharedSDK<GameState, GameActions extends UntypedInitLogicActions> = {
    initLogic: (params: InitLogicParams<GameState, GameActions>) => void;
    invalidAction: () => Error;
    gameOver: (options?: GameOverOptions) => void;
    gameTimeInSeconds: () => number;
};

type LogicRunnerContext = {
    randomSeed: RandomSeed;
    msPerTick: number;
    logicTick: number;
};
type LogicRunnerGameContext = {
    gameOver: GameOverContext | null;
};
type LogicRunnerReturnType<GameState> = {
    game: GameState;
    gameContext: LogicRunnerGameContext;
};
type LogicRunnerAction<GameState> = (params: any, actionContext: ActionContext<GameState>, logicContext: LogicRunnerContext) => LogicRunnerReturnType<GameState> | false;
type LogicRunnerActions<GameState> = Record<string, LogicRunnerAction<GameState>>;
type LogicRunnerUpdate<GameState> = (updateContext: UpdateContext<GameState>, logicContext: LogicRunnerContext) => LogicRunnerReturnType<GameState>;
type LogicRunnerEvent<GameState> = (playerId: PlayerId, eventContext: EventContext<GameState>, logicContext: LogicRunnerContext) => LogicRunnerReturnType<GameState>;
type LogicRunnerEvents<GameState> = {
    playerJoined?: LogicRunnerEvent<GameState>;
    playerLeft?: LogicRunnerEvent<GameState>;
};
type RuneServer<GameState, GameActions extends UntypedInitLogicActions> = {
    gameConfig?: GameConfig;
    setup?: (playerIds: PlayerId[], logicContext: LogicRunnerContext) => GameState;
    actions?: LogicRunnerActions<GameState>;
    events?: LogicRunnerEvents<GameState>;
    update?: LogicRunnerUpdate<GameState>;
    logicContext: LogicRunnerContext;
    gameOverContext: GameOverContext | null;
} & RuneSharedSDK<GameState, GameActions>;

type PlayersRandomState = Record<PlayerId, {
    seed: RandomSeed;
    actionCount: number;
}>;
type GameContext = {
    gameOver: GameOverContext | null;
    orderNumber: number;
    sessionId: SessionId;
    gameId: GameId;
};
type ServerSerializationData<GameState> = {
    game: GameState;
    context: GameContext;
    random: PlayersRandomState;
    gameTime: number;
    updateCount: number;
};
type UpdateLoopContext = {
    logicTick: number;
};
type RunGameLogic<GameState> = {
    getConfig: () => GameConfig;
    runSetup: (msgLogger: MsgLogger, playerIds: PlayerId[], logicContext: LogicRunnerContext) => Promise<GameState>;
    runEvent: (msgLogger: MsgLogger, logicContext: LogicRunnerContext, event: "playerJoined" | "playerLeft", playerId: PlayerId, eventContext: EventContext<GameState>) => Promise<LogicRunnerReturnType<GameState>>;
    runAction: (msgLogger: MsgLogger, logicContext: LogicRunnerContext, action: string, params: any, actionContext: ActionContext<GameState>) => Promise<LogicRunnerReturnType<GameState> | false>;
    runUpdate: (msgLogger: MsgLogger, logicContext: LogicRunnerContext, updateContext: UpdateContext<GameState>) => Promise<LogicRunnerReturnType<GameState>>;
};
type NetworkServer = {
    getUsers: () => Users;
    broadcastMsg: (msgLogger: MsgLogger, msg: string) => void;
    sendMsg: (msgLogger: MsgLogger, userId: UserId, msg: string) => void;
    onGameOver?: (reason: GameOverContext["reason"]) => void;
    queueUpdateLoop: (updateLoopContext: UpdateLoopContext) => void;
};
type GameServer<GameState> = {
    onMsg: (msgLogger: MsgLogger, userId: UserId, msg: string) => Promise<void>;
    onPlayerJoined: (msgLogger: MsgLogger, playerId: PlayerId) => Promise<void>;
    onPlayerLeft: (msgLogger: MsgLogger, playerId: PlayerId) => Promise<void>;
    getDataForSerialization: () => ServerSerializationData<GameState>;
    getConfig: () => GameConfig;
    getSessionId: () => SessionId;
    getGameId: () => GameId;
    onUpdateLoop: (msgLogger: MsgLogger, updateLoopContext: UpdateLoopContext) => Promise<void>;
    cleanup: () => void;
};
type CreateGameServerProps<GameState> = {
    initialMsgLogger: MsgLogger;
    gameId: GameId;
    network: NetworkServer;
    logic: RunGameLogic<GameState>;
    initialServerData?: ServerSerializationData<GameState> | {
        sessionId: SessionId;
    };
    sendInitialStateSync?: boolean;
    getSeedForPlayerId?: (playerId: PlayerId) => number;
    serverSeed: RandomSeed;
    logicTimeoutDuration?: number | false;
    sendStateHash?: boolean;
    allowedGameTimeDelay?: number;
    logServerClientGameTime?: boolean;
    logNetworkMsg?: boolean;
};

type ServerToGameBase = {
    orderNumber: number;
    serverGameTime: number;
    updateCount: number;
    uuid: string;
};
type OnChangeAction<GameActions extends UntypedInitLogicActions> = {
    [Key in keyof GameActions]: {
        action: Key;
        playerId: PlayerId;
        params: Parameters<GameActions[Key]>[0];
    };
}[keyof GameActions];
type ActionBase = {
    uuid: string;
    actionCount: number;
    sessionId: SessionId;
    randomSeed: RandomSeed;
};
type GameToServerAction<GameActions extends UntypedInitLogicActions> = OnChangeAction<GameActions> & ActionBase & {
    clientGameTime: number;
};
type ServerToGameAction<GameActions extends UntypedInitLogicActions> = ServerToGameBase & OnChangeAction<GameActions> & ActionBase & {
    stateHash: number | undefined;
};
type OnChangeStateSyncEvent = {
    event: "stateSync";
};
type ServerToGameGameTimeUpdate = ServerToGameBase & {
    event: "gameTimeUpdate";
    params: {
        gameContext: GameContext;
    };
};
type ServerToGameStateSyncEvent<GameState> = ServerToGameBase & OnChangeStateSyncEvent & {
    params: {
        game: GameState;
        gameContext: GameContext;
        players: Players;
        yourPlayerSeed: RandomSeed | undefined;
        yourPlayerActionCount: number | undefined;
        yourPlayerId: PlayerId | undefined;
        serverSeed: RandomSeed;
        triggeredByUpdateLoop: boolean;
    };
};
type OnChangePlayerJoinedEvent = {
    event: "playerJoined";
    params: {
        playerId: PlayerId;
    };
};
type ServerToGamePlayerJoinedEvent = ServerToGameBase & OnChangePlayerJoinedEvent & {
    params: {
        playerId: PlayerId;
        gameContext: GameContext;
        players: Players;
        randomSeed: RandomSeed;
        stateHash: number | undefined;
    };
};
type OnChangePlayerLeftEvent = {
    event: "playerLeft";
    params: {
        playerId: PlayerId;
    };
};
type ServerToGamePlayerLeftEvent = ServerToGameBase & OnChangePlayerLeftEvent & {
    params: {
        playerId: PlayerId;
        gameContext: GameContext;
        players: Players;
        randomSeed: RandomSeed;
        stateHash: number | undefined;
    };
};
type OnChangeTimeSyncEvent = {
    event: "timeSync";
};
type OnChangeUpdateEvent = {
    event: "update";
};
type OnChangeEvent = OnChangeStateSyncEvent | OnChangePlayerJoinedEvent | OnChangePlayerLeftEvent | OnChangeTimeSyncEvent | OnChangeUpdateEvent;
type ServerToGameOnChangeTriggeringEvent<GameState> = ServerToGameStateSyncEvent<GameState> | ServerToGamePlayerJoinedEvent | ServerToGamePlayerLeftEvent;
type ServerToGameEvent<GameState> = ServerToGameOnChangeTriggeringEvent<GameState> | ServerToGameGameTimeUpdate;
type ServerToGame<GameState, GameActions extends UntypedInitLogicActions> = ServerToGameAction<GameActions> | ServerToGameEvent<GameState>;
type GameToServer<GameActions extends UntypedInitLogicActions> = GameToServerAction<GameActions> | "REQUEST_STATE_SYNC";

type ClientToGameMultiplayer = ClientToGame | {
    type: "DISCONNECTED";
} | {
    type: "CLIPBOARD_WRITE_RES";
    reqId: string;
    success: boolean;
} | {
    type: "CLIPBOARD_READ_RES";
    reqId: string;
    text: string | null;
} | {
    type: "STORAGE_WRITE_RES";
    reqId: string;
    success: boolean;
} | {
    type: "STORAGE_READ_RES";
    reqId: string;
    value: string | null;
};
type GameToClientMultiplayer = GameToClient | {
    type: "GAME_OVER";
    context: GameOverContext;
} | {
    type: "OPEN_EXTERNAL_APP";
    url: string;
} | {
    type: "CLIPBOARD_WRITE_REQ";
    reqId: string;
    text: string;
} | {
    type: "CLIPBOARD_READ_REQ";
    reqId: string;
} | {
    type: "STORAGE_WRITE_REQ";
    reqId: string;
    key: string;
    value: string;
} | {
    type: "STORAGE_READ_REQ";
    reqId: string;
    key: string;
} | {
    type: "SHOW_GAME_OVER_POP_UP";
} | {
    type: "SHOW_INVITE_SHEET";
} | {
    type: "ON_CHANGE";
};
type GameDevSDKNetworkLayer<GameState, GameActions extends UntypedInitLogicActions> = {
    sendMsg: (msg: string) => void;
    onMsg: (callback: (msg: {
        clientToGame: ClientToGameMultiplayer;
    } | {
        serverToGame: ServerToGame<GameState, GameActions>;
    }) => void) => void;
};
type GameClient = {
    onServerMsg: (msg: string) => void;
    onGameMsg: (msg: string) => void;
    onDisconnected: () => void;
    onReconnected: () => void;
    onGameReloaded: () => void;
    sendMsgToGame: (msg: ClientToGameMultiplayer) => void;
};

type NetworkClient = {
    sendMsgToServer: (msg: string) => void;
    sendMsgToGame: (msg: string) => void;
};
type OnChange<GameState, GameActions extends UntypedInitLogicActions> = (params: {
    oldGame: GameState;
    newGame: GameState;
    action?: OnChangeAction<GameActions>;
    event?: OnChangeEvent;
    yourPlayerId: PlayerId | undefined;
    players: Players;
    rollbacks: OnChangeAction<GameActions>[];
}) => void;
type RuneClient<GameState, GameActions extends UntypedInitLogicActions> = {
    initClient: (params: {
        onChange: OnChange<GameState, GameActions>;
    }) => void;
    actions: GameActions;
    version: string;
    openExternalApp: (url: string) => void;
    clipboardWrite: (text: string) => Promise<{
        success: boolean;
    }>;
    clipboardRead: () => Promise<{
        text: string | null;
    }>;
    storageWrite: (key: string, value: string) => Promise<{
        success: boolean;
    }>;
    storageRead: (key: string) => Promise<{
        value: string | null;
    }>;
    showGameOverPopUp: () => void;
    showInvitePlayers: () => void;
} & RuneSharedSDK<GameState, GameActions>;

type OnGameStateChangedStates = {
    state: "LOADING";
} | {
    state: "PLAYING";
} | {
    state: "ERR";
} | {
    state: "GAME_OVER";
    context: GameOverContext;
};

declare const Rune: RuneClient<UntypedGameState, UntypedInitLogicActions>;

export { ActionContext, ClientToGameMultiplayer, CreateGameServerProps, EventContext, GameClient, GameConfig, GameContext, GameDevSDKNetworkLayer, GameId, GameOverContext, GameOverOptions, GameServer, GameToClientMultiplayer, GameToServer, GameToServerAction, InitLogicActions, InitLogicEvents, InitLogicParams, InitLogicUpdate, LogicRunnerContext, LogicRunnerGameContext, LogicRunnerReturnType, MsgLogger, NetworkClient, NetworkServer, OnChange, OnChangeAction, OnChangeEvent, OnChangePlayerJoinedEvent, OnChangePlayerLeftEvent, OnChangeStateSyncEvent, OnChangeTimeSyncEvent, OnChangeUpdateEvent, OnGameStateChangedStates, Player, PlayerId, Players, PlayersRandomState, RandomSeed, RunGameLogic, RuneClient, RuneServer, RuneSharedSDK, ServerSerializationData, ServerToGame, ServerToGameAction, ServerToGameEvent, ServerToGameGameTimeUpdate, ServerToGameOnChangeTriggeringEvent, ServerToGamePlayerJoinedEvent, ServerToGamePlayerLeftEvent, ServerToGameStateSyncEvent, SessionId, Spectator, UntypedGameState, UntypedInitLogicActions, UpdateContext, User, UserId, Users, Rune as default };
