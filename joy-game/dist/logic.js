const i=t=>t.challengeCounter>0?(console.log("Can't win before Conquering challenge"),!1):Object.values(t.diceCount).some(e=>e<=0);function l(t){const e={};for(let n=1;n<=6;n++)e[n]=0;return t.forEach(n=>{e.hasOwnProperty(n)&&e[n]++}),e}const a=t=>Object.entries(t.diceCount).reduce((e,[n,r])=>{const o=r<=0?"WON":"LOST";return e[n]=o,e},{});Rune.initLogic({minPlayers:1,maxPlayers:4,setup:t=>{const e=Object.fromEntries(t.map(o=>[o,5])),n=Array.from({length:5},()=>4),r=l(n);return{gameDice:n,diceCount:e,diceHistogram:r,currentPlayerIndex:0,previousPlayerIndex:0,challengeCounter:0,challengeStatus:!1,playerToRoll:!0,playerPlaying:!1,gameOver:!1,showHelp:!1}},actions:{updateDiceCount:({playerId:t,amount:e},{game:n})=>{if(t===void 0)t="spectator";else if(n.diceCount[t]===void 0)throw Rune.invalidAction();n.diceCount[t]+=e,i(n)&&Rune.gameOver({players:a(n)})},updateChallengeCount:({amount:t},{game:e})=>{e.challengeCounter+=t},updateChallengeStatus:({status:t},{game:e})=>{e.challengeStatus=t},rollDice:({numDice:t},{game:e})=>{e.gameDice=Array.from({length:t},()=>Math.floor(Math.random()*6)+1),e.playerToRoll=!1,e.playerPlaying=!0},nextPlayer:({nextIndex:t},{game:e})=>{e.gameOver||(e.previousPlayerIndex=e.currentPlayerIndex,e.currentPlayerIndex=t,e.playerToRoll=!0,e.playerPlaying=!1)},adjustGameDice:({index:t},{game:e})=>{e.gameDice.splice(t,1),e.diceHistogram=l(e.gameDice)}},events:{playerJoined:(t,{game:e})=>{e.diceCount[t]=5},playerLeft(t,{game:e}){delete e.diceCount[t]}}});
