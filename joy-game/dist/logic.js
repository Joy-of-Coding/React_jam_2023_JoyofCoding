const l=t=>{for(const e in t.diceCount)if(t.diceCount[e]<=0)return!0;return!1},s=t=>Object.entries(t.diceCount).reduce((e,[i,n])=>{const o=n<=0?"WON":"LOST";return e[i]=o,e},{});Rune.initLogic({minPlayers:1,maxPlayers:4,setup:t=>{const e=Object.fromEntries(t.map(i=>[i,10]));return{gameDice:[],diceCount:e,currentPlayerIndex:0,previousPlayerIndex:-1,selectedPlayerId:"",playerToRoll:!0,playerPlaying:!1,gameOver:!1,showHelp:!1,selectedDieIndex:-1}},actions:{shareCake:({playerId:t,playerIds:e,dieIndex:i},{game:n})=>{if(t===void 0)t="spectator";else if(n.diceCount[t]===void 0)throw Rune.invalidAction();const o=[];for(let r=0;r<e.length;r++){const c=e[r];c!==t&&c!=null&&o.push(c)}for(let r=0;r<o.length;r++){const c=o[r];if(c===void 0||n.diceCount[c]===void 0)throw Rune.invalidAction();n.diceCount[c]+=1}n.diceCount[t]+=-1,n.gameDice.splice(i,1),l(n)&&Rune.gameOver({players:s(n)})},popBalloons:({playerId:t,dieIndex:e},{game:i})=>{if(t===void 0)t="spectator";else if(i.diceCount[t]===void 0)throw Rune.invalidAction();i.diceCount[t]+=-1,i.gameDice.splice(e,1),l(i)&&Rune.gameOver({players:s(i)})},setSelectedDieIndex:({dieIndex:t},{game:e})=>{e.selectedDieIndex=t},giveGifts:({playerId:t,opponentId:e,dieIndex:i},{game:n})=>{if(t===void 0)t="spectator";else if(n.diceCount[t]===void 0)throw Rune.invalidAction();let o=Math.floor(Math.random()*5-2);o===0&&(o=1),n.diceCount[e]+=o,n.diceCount[t]+=-1,n.gameDice.splice(i,1),l(n)&&Rune.gameOver({players:s(n)})},updateDiceCount:({playerId:t,amount:e},{game:i})=>{if(t===void 0)t="spectator";else if(i.diceCount[t]===void 0)throw Rune.invalidAction();i.diceCount[t]+=e,l(i)&&Rune.gameOver({players:s(i)})},rollDice:({numDice:t},{game:e})=>{e.gameDice=Array.from({length:t},()=>Math.floor(Math.random()*6)+1),e.playerToRoll=!1,e.playerPlaying=!0},nextPlayer:({nextIndex:t},{game:e})=>{e.gameOver||(e.previousPlayerIndex=e.currentPlayerIndex,e.currentPlayerIndex=t,e.playerToRoll=!0,e.playerPlaying=!1,e.gameDice=[])},adjustGameDice:({index:t},{game:e})=>{e.gameDice.splice(t,1)},setPreviousPlayer:({playerIndex:t},{game:e})=>{e.previousPlayerIndex=t},setSelectedPlayerId:({playerId:t},{game:e})=>{e.selectedPlayerId=t}},events:{playerJoined:(t,{game:e})=>{e.diceCount[t]=10},playerLeft(t,{game:e}){delete e.diceCount[t],e.currentPlayerIndex=Object.keys(e.diceCount).length-1,e.playerToRoll=!0,e.playerPlaying=!1,e.gameDice=[]}}});
